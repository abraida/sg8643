<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

		<div id="contenedor3d">
			<center>    		            
				<canvas id="canvas" width=1500 height=1000>
					Your browser does not support the HTML5 canvas element.
				</canvas>    		
			</center>
		</div>

        <script type="text/javascript" src="js/import/gl-matrix.js"></script>
        <script src="js/import/dat.gui.js"></script>
		<script src="js/import/jquery-3.6.1.min.js"></script>
        
        <script src="js/src/paths.js"></script>
        <script src="js/src/shapes.js"></script>

        <script src="js/src/superficies.js"></script>
		<script src="js/src/Objeto.js"></script>
		<script src="js/src/Castillo.js"></script>
		<script src="js/src/Catapulta.js"></script>
		<script src="js/src/Terreno.js"></script>
		<script src="js/src/Camara.js"></script>
		<script src="js/init.js"></script>
        
        <script src="js/main.js"></script>
		<script src="js/src/interfaz.js"></script>



        <script id="shader-vs" type="x-shader/x-vertex">
            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;
            
            uniform mat4 normalMatrix;

            uniform vec3 uColor;
            uniform vec3 uCamPos;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  
            varying vec3 vColor;
            varying vec3 vCamPosWorld;


            varying vec2 vTextureCoord;


            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo   
                vCamPosWorld=(modelMatrix*vec4(uCamPos,1.0)).xyz;    //la posicion en coordenadas de mundo


                vColor = uColor;    
                vTextureCoord = aTextureCoord;
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            #define N_LIGHTS 4 
            
            precision highp float;

            varying vec3 vNormal;
            varying vec3 vPosWorld;
            varying vec3 vCamPosWorld;

            varying vec3 vColor;
            
            varying vec2 vTextureCoord;
            uniform sampler2D uZincTex;


            uniform vec3 uAmbientColor;	    

            uniform vec3 uLightColor[N_LIGHTS];
            uniform vec3 uLightPos[N_LIGHTS];
            uniform vec3 uLightConst[N_LIGHTS];
            uniform bool uLightIsDirectional[N_LIGHTS];

            uniform bool usarTextura;
            uniform bool debugMode;

            vec3 CalcDirLight(vec3 lightColor, vec3 dir) {
                float shininessVal = 100.0;
                
                vec3 N = normalize(vNormal);
                vec3 L = normalize(dir);

                float diff = max(dot(N, L), 0.0);
                float specular = 0.0;
                
                if(diff > 0.0) {
                    vec3 R = reflect(-L, N);      // Reflected light vector
                    vec3 V = normalize(vCamPosWorld-vPosWorld); // Vector to viewer
                    // Compute the specular term
                    float specAngle = max(dot(R, V), 0.0);
                    specular = pow(specAngle, shininessVal);
                }

                if (usarTextura) {
                    vec3 tex = texture2D(uZincTex, vTextureCoord).xyz;
                    return  (diff * lightColor * tex + 
                             .5 *tex * specular * lightColor);        
                }

                return (.8 * diff * lightColor * vColor + 
                             0.05 * specular * lightColor); 
            }  

            vec3 CalcPointLight(vec3 lightColor, vec3 pos, vec3 coeff) {
                float shininessVal = 150.0;
                
                vec3 N = normalize(vNormal);
                vec3 L = normalize(pos - vPosWorld);

                float diff = max(dot(N, L), 0.0);
                float specular = 0.0;
                
                if(diff > 0.0) {
                    vec3 R = reflect(-L, N);      // Reflected light vector
                    vec3 V = normalize(vCamPosWorld-vPosWorld); // Vector to viewer
                    // Compute the specular term
                    float specAngle = max(dot(R, V), 0.0);
                    specular = pow(specAngle, shininessVal);
                }

                float distance = length(pos - vPosWorld);
                
                float attenuation = 1.0 / (coeff[0] + coeff[1] * distance + 
  			     coeff[2] * (distance * distance));

                if (usarTextura) {
                    vec3 tex = texture2D(uZincTex, vTextureCoord).xyz;
                    return  (diff * lightColor * tex * attenuation + 
                             0.5 * tex * specular * lightColor * attenuation);        
                }

                return (.8 * diff * lightColor * vColor * attenuation + 
                             .5 * specular * lightColor * attenuation); 
            }  

            void main(void) {
                if (debugMode) {
                    vec3 result = vNormal + vec3(0.2, 0.2, 0.2);
                    gl_FragColor = vec4(result, 1.0);
                    return;
                }

                vec3 result = vec3(0, 0, 0);

                for(int i = 0; i < N_LIGHTS; i++) {
                    if(uLightIsDirectional[i]){
                        result += CalcDirLight(uLightColor[i], uLightPos[i]);    
                    }
                    else {
                        result += CalcPointLight(uLightColor[i], uLightPos[i], uLightConst[i]);    

                    }
                }

                if (usarTextura) {
                    vec3 tex = texture2D(uZincTex, vTextureCoord).xyz;
                    result += uAmbientColor * tex;        
                    gl_FragColor = vec4(result, 1.0);
                    return;
                }

                result += uAmbientColor * .5;        
                gl_FragColor = vec4(result, 1.0);
            }
        </script>
        
    </body>
</html>
