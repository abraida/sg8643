<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

		<div id="contenedor3d">
			<center>    		            
				<canvas id="my-canvas" width="1000" height="800">
					Your browser does not support the HTML5 canvas element.
				</canvas>    		
			</center>
		</div>

        <script type="text/javascript" src="js/gl-matrix.js"></script>
		<script src="js/jquery-3.6.1.min.js"></script>
        <script src="js/curvas.js"></script>
        <script src="js/superficies.js"></script>
		<script src="js/Objeto.js"></script>
		<script src="js/castillo.js"></script>
		<script src="js/terreno.js"></script>
		<script src="js/camara.js"></script>

        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0));
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);

               gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script>
            var mat4 = glMatrix.mat4;
            var vec3 = glMatrix.vec3;
            
            var gl = null;
            
            var canvas = null,
            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
            
            var vertexPositionAttribute = null,
            trianglesVerticeBuffer = null,
            vertexNormalAttribute = null,
            trianglesNormalBuffer = null,
            trianglesIndexBuffer = null;
            
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            var normalMatrix = mat4.create();
            var rotate_angle = -1.57078;
            
            var castillo = null;
            var terreno = null;
            
			var camara = new Camara();

            var modo = "edges";
            var aspect=null;
            
            var mallaDeTriangulos = null;

			$("body").mousemove(function (e) {	
				camara.movimientoMouse(e.clientX || e.pageX, e.clientY || e.pageY);
			});

			$('body').mousedown(function (event) {
				camara.mouseDown();

			});

			$('body').mouseup(function (event) {
				camara.mouseUp();
			});

			function zoom(event) {
				if (event.deltaY < 0) {					
					camara.disminuirZoom(event.deltaY * -0.001);
				} else {
					camara.aumentarZoom(event.deltaY * 0.001);				
				}
			}
			document.addEventListener('wheel', zoom);
            
            function initWebGL() {
				canvas = document.getElementById("my-canvas");
				
				try {
					gl = canvas.getContext("webgl");
				} catch (e) {
				alert("Error: Your browser does not appear to support WebGL.");
				}
				
				if (gl) {
					setupWebGL();
					initShaders();
					setupVertexShaderMatrix();
					setupModelos();
					drawScene();
					tick();
				} else {
					alert("Error: Your browser does not appear to support WebGL.");
				}
            }
            
            function setupWebGL() {
				gl.enable(gl.DEPTH_TEST);
				//set the clear color
				gl.clearColor(0.1, 0.1, 0.2, 1.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				
				gl.viewport(0, 0, canvas.width, canvas.height);
				
				aspect = canvas.width/canvas.height;
            
				// Matrix de Proyeccion Perspectiva


				mat4.perspective(projMatrix, 45, canvas.width / canvas.height, 0.1, 100.0);
				
				mat4.identity(viewMatrix);
				mat4.translate(viewMatrix, viewMatrix, [0.0, 0.0, -5.0]);
            }
            
            function initShaders() {
            //get shader source
            var fs_source = document.getElementById("shader-fs").innerHTML,
            vs_source = document.getElementById("shader-vs").innerHTML;
            
            //compile shaders
            vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
            fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
            
            //create program
            glProgram = gl.createProgram();
            
            //attach and link shaders to the program
            gl.attachShader(glProgram, vertexShader);
            gl.attachShader(glProgram, fragmentShader);
            gl.linkProgram(glProgram);
            
            if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
            alert("Unable to initialize the shader program.");
            }
            
            //use program
            gl.useProgram(glProgram);
            }
            
            function makeShader(src, type) {
            //compile the vertex shader
            var shader = gl.createShader(type);
            gl.shaderSource(shader, src);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
            }
            return shader;
            }
            
            function setupVertexShaderMatrix() {
            var modelMatrixUniform = gl.getUniformLocation(glProgram, "modelMatrix");
            var viewMatrixUniform = gl.getUniformLocation(glProgram, "viewMatrix");
            var projMatrixUniform = gl.getUniformLocation(glProgram, "projMatrix");
            var normalMatrixUniform = gl.getUniformLocation(glProgram, "normalMatrix");
            
            gl.uniformMatrix4fv(modelMatrixUniform, false, modelMatrix);
            gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
            gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
            gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
            }
            
            function setupModelos() {
				castillo = crear_castillo(10, 10, 4);
				castillo.setProgram(glProgram);
				castillo.setPosicion(0, 0, 0);

				terreno = crear_terreno();
				terreno.setProgram(glProgram);
				terreno.setPosicion(0, 0, 0);

				castillo.setEscala(.1, .1, .1);
				terreno.setEscala(.1, .1, .1);

	
            }
            
            function dibujarMalla(mallaDeTriangulos) {
                vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, mallaDeTriangulos.webgl_position_buffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
                
                vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                gl.enableVertexAttribArray(vertexNormalAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, mallaDeTriangulos.webgl_normal_buffer);
                gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mallaDeTriangulos.webgl_index_buffer);
                gl.drawElements( gl.TRIANGLES, mallaDeTriangulos.webgl_index_buffer.number_vertex_point, gl.UNSIGNED_SHORT, 0);
            }
            
            function drawScene() {
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);	
							
				mat4.lookAt(viewMatrix,
				vec3.fromValues(camara.pos[0], camara.pos[1], camara.pos[2]),
				vec3.fromValues(0, 0, 0),
				vec3.fromValues(0, 1, 0)
				);
				
				setupVertexShaderMatrix();

				let m = mat4.create;
				mat4.identity(m, m);
				castillo.dibujar(m);
				terreno.dibujar(m);
            }
            

			function tick() {
				requestAnimationFrame(tick);
				camara.rotar();
				drawScene();
			}

            window.onload = initWebGL;
        </script>

    </body>
</html>
